import asyncio
from datetime import datetime, timezone
from pathlib import Path

from pydantic import BaseModel, ConfigDict

from claude_agent_sdk import ClaudeAgentOptions, ResultMessage, query

from devpack.config import load_api_key
from devpack.models import Agent, DetectedTechnology, IDETarget, Skill

_GUIDE_DIR = ".devpack"
_GUIDE_FILENAME = "GUIDE.md"
_GITIGNORE_ENTRY = ".devpack/"

_IDE_INVOKE = {
    "claude-code": "`/{id}` in a Claude Code chat",
    "cursor": "`@{id}` in a Cursor chat",
    "vscode": "`#{id}` in a VS Code Copilot chat",
}


class _ExplanationsResult(BaseModel):
    model_config = ConfigDict(extra="forbid")

    # Maps skill ID → human-targeted usage explanation
    explanations: dict[str, str]


def write_guide(
    repo_path: Path,
    skills: list[Skill],
    ide: IDETarget,
    stack: list[DetectedTechnology],
    agents: list[Agent] | None = None,
) -> Path:
    """Write a local (gitignored) guide explaining each installed skill and agent."""
    agents = agents or []
    explanations = _generate_explanations(skills, agents, ide)

    guide_dir = repo_path / _GUIDE_DIR
    guide_dir.mkdir(exist_ok=True)

    guide_path = guide_dir / _GUIDE_FILENAME
    guide_path.write_text(
        _build_guide(skills, ide, stack, explanations, agents), encoding="utf-8"
    )

    _ensure_gitignored(repo_path)

    return guide_path


# --- Private helpers ---


def _generate_explanations(
    skills: list[Skill], agents: list[Agent], ide: IDETarget
) -> dict[str, str]:
    """Call Claude to generate human-targeted usage explanations for skills and agents."""
    if not load_api_key():
        return {}

    try:
        return asyncio.run(_generate_explanations_async(skills, agents, ide))
    except Exception:
        return {}


async def _generate_explanations_async(
    skills: list[Skill], agents: list[Agent], ide: IDETarget
) -> dict[str, str]:
    invoke_template = _IDE_INVOKE.get(ide.id, "your IDE")

    skill_blocks = []
    for skill in skills:
        invocation = invoke_template.format(id=skill.id)
        content = _read_skill_md(skill)
        skill_blocks.append(
            f"=== {skill.id} ===\n" f"Invocation: {invocation}\n\n" f"{content}"
        )

    for agent in agents:
        content = agent.path.read_text(encoding="utf-8")
        skill_blocks.append(
            f"=== {agent.id} ===\n"
            f'Invocation: use the Task tool with subagent_type="{agent.id}"\n\n'
            f"{content}"
        )

    if not skill_blocks:
        return {}

    prompt = f"""You are writing the "how to use" section of a developer onboarding guide for AI agent skills and subagents.

For each item below, write 2-3 sentences that tell a developer:
1. The specific situation when they should reach for this skill or agent (be concrete, not abstract)
2. Exactly how to invoke it — use the invocation command provided
3. What they will get back

Rules:
- Write for a human developer, not for an AI model
- Do not restate or paraphrase the item's own description back at them
- Do not start with the skill or agent name
- Be direct and practical — tell them what to do, not what the skill "is"

Return a JSON object mapping each ID (the text between === markers) to its explanation string.

Skills and agents:
{chr(10).join(skill_blocks)}
"""

    options = ClaudeAgentOptions(
        allowed_tools=[],
        output_format={
            "type": "json_schema",
            "schema": _ExplanationsResult.model_json_schema(),
        },
    )

    structured_output = None
    async for message in query(prompt=prompt, options=options):
        if isinstance(message, ResultMessage):
            structured_output = message.structured_output

    if structured_output is None:
        return {}

    result = _ExplanationsResult.model_validate(structured_output)
    return result.explanations


def _read_skill_md(skill: Skill) -> str:
    """Return the full text of SKILL.md, falling back to the description."""
    skill_md = skill.path / "SKILL.md"
    try:
        return skill_md.read_text(encoding="utf-8")
    except OSError:
        return f"Description: {skill.description}"


def _build_guide(
    skills: list[Skill],
    ide: IDETarget,
    stack: list[DetectedTechnology],
    explanations: dict[str, str],
    agents: list[Agent] | None = None,
) -> str:
    agents = agents or []
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    invoke_template = _IDE_INVOKE.get(ide.id, "See your IDE documentation for `{id}`")
    stack_line = (
        ", ".join(t.name for t in stack) if stack else "No specific stack detected."
    )

    lines = [
        "# DevPack — Installed Skills Guide",
        "",
        f"> Generated by DevPack on {timestamp}.  ",
        "> This file is gitignored — it is a local reference for developers, not committed to the repo.",
        "",
        "## Detected Stack",
        "",
        stack_line,
        "",
        "---",
        "",
        "## Installed Skills",
        "",
        f"The following {len(skills)} skill(s) are installed for **{ide.name}**.",
        "",
    ]

    for skill in skills:
        invoke = invoke_template.format(id=skill.id)
        explanation = explanations.get(skill.id) or skill.description

        lines += [
            "---",
            "",
            f"### {skill.name}",
            "",
            f"**How to invoke:** {invoke}  ",
            f"**Installed at:** `{ide.skill_path}/{skill.id}/`",
            "",
            explanation,
            "",
        ]

    if agents:
        lines += [
            "---",
            "",
            "## Installed Agents",
            "",
            f"The following {len(agents)} agent(s) are installed at `.claude/agents/`.",
            "",
        ]

        for agent in agents:
            explanation = explanations.get(agent.id) or agent.description

            lines += [
                "---",
                "",
                f"### {agent.name}",
                "",
                f'**How to invoke:** Use the Task tool with `subagent_type="{agent.id}"`  ',
                f"**Installed at:** `.claude/agents/{agent.id}.md`",
                "",
                explanation,
                "",
            ]

    lines += [
        "---",
        "",
        "_Re-run `devpack add-skills` at any time to update this guide and your installed skills._",
    ]

    return "\n".join(lines)


def _ensure_gitignored(repo_path: Path) -> None:
    """Append .devpack/ to .gitignore if it isn't already listed."""
    gitignore = repo_path / ".gitignore"
    bare_entry = _GITIGNORE_ENTRY.rstrip("/")

    if gitignore.exists():
        content = gitignore.read_text(encoding="utf-8")
        if _GITIGNORE_ENTRY in content or (bare_entry + "\n") in content:
            return
        separator = "" if content.endswith("\n") else "\n"
        gitignore.write_text(
            content + separator + f"\n# DevPack local guide\n{_GITIGNORE_ENTRY}\n",
            encoding="utf-8",
        )
    else:
        gitignore.write_text(
            f"# DevPack local guide\n{_GITIGNORE_ENTRY}\n", encoding="utf-8"
        )
